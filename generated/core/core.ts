/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: core/core.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace core {
	export class Status extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						succeeded?: boolean;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("succeeded" in data && data.succeeded != undefined) {
					this.succeeded = data.succeeded;
				}
			}
		}
		get succeeded() {
			return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
		}
		set succeeded(value: boolean) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: { succeeded?: boolean }): Status {
			const message = new Status({});
			if (data.succeeded != null) {
				message.succeeded = data.succeeded;
			}
			return message;
		}
		toObject() {
			const data: {
				succeeded?: boolean;
			} = {};
			if (this.succeeded != null) {
				data.succeeded = this.succeeded;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.succeeded != false) writer.writeBool(1, this.succeeded);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Status {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new Status();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.succeeded = reader.readBool();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Status {
			return Status.deserialize(bytes);
		}
	}
	export class TransactionId extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						transaction_id?: string;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if (
					"transaction_id" in data &&
					data.transaction_id != undefined
				) {
					this.transaction_id = data.transaction_id;
				}
			}
		}
		get transaction_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
		}
		set transaction_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: { transaction_id?: string }): TransactionId {
			const message = new TransactionId({});
			if (data.transaction_id != null) {
				message.transaction_id = data.transaction_id;
			}
			return message;
		}
		toObject() {
			const data: {
				transaction_id?: string;
			} = {};
			if (this.transaction_id != null) {
				data.transaction_id = this.transaction_id;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.transaction_id.length)
				writer.writeString(1, this.transaction_id);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(
			bytes: Uint8Array | pb_1.BinaryReader,
		): TransactionId {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new TransactionId();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.transaction_id = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TransactionId {
			return TransactionId.deserialize(bytes);
		}
	}
	export class UserId extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						user_id?: string;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("user_id" in data && data.user_id != undefined) {
					this.user_id = data.user_id;
				}
			}
		}
		get user_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
		}
		set user_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: { user_id?: string }): UserId {
			const message = new UserId({});
			if (data.user_id != null) {
				message.user_id = data.user_id;
			}
			return message;
		}
		toObject() {
			const data: {
				user_id?: string;
			} = {};
			if (this.user_id != null) {
				data.user_id = this.user_id;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.user_id.length) writer.writeString(1, this.user_id);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserId {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new UserId();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.user_id = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): UserId {
			return UserId.deserialize(bytes);
		}
	}
	export class TransactionLimit extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						limit?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("limit" in data && data.limit != undefined) {
					this.limit = data.limit;
				}
			}
		}
		get limit() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set limit(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: { limit?: number }): TransactionLimit {
			const message = new TransactionLimit({});
			if (data.limit != null) {
				message.limit = data.limit;
			}
			return message;
		}
		toObject() {
			const data: {
				limit?: number;
			} = {};
			if (this.limit != null) {
				data.limit = this.limit;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.limit != 0) writer.writeInt64(1, this.limit);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(
			bytes: Uint8Array | pb_1.BinaryReader,
		): TransactionLimit {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new TransactionLimit();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.limit = reader.readInt64();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TransactionLimit {
			return TransactionLimit.deserialize(bytes);
		}
	}
	export class CurrencyValue extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						value?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("value" in data && data.value != undefined) {
					this.value = data.value;
				}
			}
		}
		get value() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set value(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: { value?: number }): CurrencyValue {
			const message = new CurrencyValue({});
			if (data.value != null) {
				message.value = data.value;
			}
			return message;
		}
		toObject() {
			const data: {
				value?: number;
			} = {};
			if (this.value != null) {
				data.value = this.value;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.value != 0) writer.writeFloat(1, this.value);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(
			bytes: Uint8Array | pb_1.BinaryReader,
		): CurrencyValue {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new CurrencyValue();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.value = reader.readFloat();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): CurrencyValue {
			return CurrencyValue.deserialize(bytes);
		}
	}
	export class Transaction extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						transaction_id?: string;
						sender?: string;
						receiver?: string;
						amount?: number;
						timestamp?: string;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if (
					"transaction_id" in data &&
					data.transaction_id != undefined
				) {
					this.transaction_id = data.transaction_id;
				}
				if ("sender" in data && data.sender != undefined) {
					this.sender = data.sender;
				}
				if ("receiver" in data && data.receiver != undefined) {
					this.receiver = data.receiver;
				}
				if ("amount" in data && data.amount != undefined) {
					this.amount = data.amount;
				}
				if ("timestamp" in data && data.timestamp != undefined) {
					this.timestamp = data.timestamp;
				}
			}
		}
		get transaction_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
		}
		set transaction_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get sender() {
			return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
		}
		set sender(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get receiver() {
			return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
		}
		set receiver(value: string) {
			pb_1.Message.setField(this, 3, value);
		}
		get amount() {
			return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
		}
		set amount(value: number) {
			pb_1.Message.setField(this, 4, value);
		}
		get timestamp() {
			return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
		}
		set timestamp(value: string) {
			pb_1.Message.setField(this, 5, value);
		}
		static fromObject(data: {
			transaction_id?: string;
			sender?: string;
			receiver?: string;
			amount?: number;
			timestamp?: string;
		}): Transaction {
			const message = new Transaction({});
			if (data.transaction_id != null) {
				message.transaction_id = data.transaction_id;
			}
			if (data.sender != null) {
				message.sender = data.sender;
			}
			if (data.receiver != null) {
				message.receiver = data.receiver;
			}
			if (data.amount != null) {
				message.amount = data.amount;
			}
			if (data.timestamp != null) {
				message.timestamp = data.timestamp;
			}
			return message;
		}
		toObject() {
			const data: {
				transaction_id?: string;
				sender?: string;
				receiver?: string;
				amount?: number;
				timestamp?: string;
			} = {};
			if (this.transaction_id != null) {
				data.transaction_id = this.transaction_id;
			}
			if (this.sender != null) {
				data.sender = this.sender;
			}
			if (this.receiver != null) {
				data.receiver = this.receiver;
			}
			if (this.amount != null) {
				data.amount = this.amount;
			}
			if (this.timestamp != null) {
				data.timestamp = this.timestamp;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.transaction_id.length)
				writer.writeString(1, this.transaction_id);
			if (this.sender.length) writer.writeString(2, this.sender);
			if (this.receiver.length) writer.writeString(3, this.receiver);
			if (this.amount != 0) writer.writeFloat(4, this.amount);
			if (this.timestamp.length) writer.writeString(5, this.timestamp);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transaction {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new Transaction();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.transaction_id = reader.readString();
						break;
					case 2:
						message.sender = reader.readString();
						break;
					case 3:
						message.receiver = reader.readString();
						break;
					case 4:
						message.amount = reader.readFloat();
						break;
					case 5:
						message.timestamp = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Transaction {
			return Transaction.deserialize(bytes);
		}
	}
	export class TransactionUpdate extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						transaction_id?: string;
						sender?: string;
						receiver?: string;
						amount?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if (
					"transaction_id" in data &&
					data.transaction_id != undefined
				) {
					this.transaction_id = data.transaction_id;
				}
				if ("sender" in data && data.sender != undefined) {
					this.sender = data.sender;
				}
				if ("receiver" in data && data.receiver != undefined) {
					this.receiver = data.receiver;
				}
				if ("amount" in data && data.amount != undefined) {
					this.amount = data.amount;
				}
			}
		}
		get transaction_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
		}
		set transaction_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get sender() {
			return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
		}
		set sender(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get receiver() {
			return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
		}
		set receiver(value: string) {
			pb_1.Message.setField(this, 3, value);
		}
		get amount() {
			return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
		}
		set amount(value: number) {
			pb_1.Message.setField(this, 4, value);
		}
		static fromObject(data: {
			transaction_id?: string;
			sender?: string;
			receiver?: string;
			amount?: number;
		}): TransactionUpdate {
			const message = new TransactionUpdate({});
			if (data.transaction_id != null) {
				message.transaction_id = data.transaction_id;
			}
			if (data.sender != null) {
				message.sender = data.sender;
			}
			if (data.receiver != null) {
				message.receiver = data.receiver;
			}
			if (data.amount != null) {
				message.amount = data.amount;
			}
			return message;
		}
		toObject() {
			const data: {
				transaction_id?: string;
				sender?: string;
				receiver?: string;
				amount?: number;
			} = {};
			if (this.transaction_id != null) {
				data.transaction_id = this.transaction_id;
			}
			if (this.sender != null) {
				data.sender = this.sender;
			}
			if (this.receiver != null) {
				data.receiver = this.receiver;
			}
			if (this.amount != null) {
				data.amount = this.amount;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.transaction_id.length)
				writer.writeString(1, this.transaction_id);
			if (this.sender.length) writer.writeString(2, this.sender);
			if (this.receiver.length) writer.writeString(3, this.receiver);
			if (this.amount != 0) writer.writeFloat(4, this.amount);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(
			bytes: Uint8Array | pb_1.BinaryReader,
		): TransactionUpdate {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new TransactionUpdate();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.transaction_id = reader.readString();
						break;
					case 2:
						message.sender = reader.readString();
						break;
					case 3:
						message.receiver = reader.readString();
						break;
					case 4:
						message.amount = reader.readFloat();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TransactionUpdate {
			return TransactionUpdate.deserialize(bytes);
		}
	}
	export class TransactionList extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						list?: Transaction[];
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[1],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("list" in data && data.list != undefined) {
					this.list = data.list;
				}
			}
		}
		get list() {
			return pb_1.Message.getRepeatedWrapperField(
				this,
				Transaction,
				1,
			) as Transaction[];
		}
		set list(value: Transaction[]) {
			pb_1.Message.setRepeatedWrapperField(this, 1, value);
		}
		static fromObject(data: {
			list?: ReturnType<typeof Transaction.prototype.toObject>[];
		}): TransactionList {
			const message = new TransactionList({});
			if (data.list != null) {
				message.list = data.list.map((item) =>
					Transaction.fromObject(item),
				);
			}
			return message;
		}
		toObject() {
			const data: {
				list?: ReturnType<typeof Transaction.prototype.toObject>[];
			} = {};
			if (this.list != null) {
				data.list = this.list.map((item: Transaction) =>
					item.toObject(),
				);
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.list.length)
				writer.writeRepeatedMessage(1, this.list, (item: Transaction) =>
					item.serialize(writer),
				);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(
			bytes: Uint8Array | pb_1.BinaryReader,
		): TransactionList {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new TransactionList();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(message.list, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								1,
								Transaction.deserialize(reader),
								Transaction,
							),
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TransactionList {
			return TransactionList.deserialize(bytes);
		}
	}
	export class AuditReport extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						discrepancies_found?: string;
						issues?: Issue[];
				  },
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[2],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
				if (
					"discrepancies_found" in data &&
					data.discrepancies_found != undefined
				) {
					this.discrepancies_found = data.discrepancies_found;
				}
				if ("issues" in data && data.issues != undefined) {
					this.issues = data.issues;
				}
			}
		}
		get discrepancies_found() {
			return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
		}
		set discrepancies_found(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get issues() {
			return pb_1.Message.getRepeatedWrapperField(
				this,
				Issue,
				2,
			) as Issue[];
		}
		set issues(value: Issue[]) {
			pb_1.Message.setRepeatedWrapperField(this, 2, value);
		}
		static fromObject(data: {
			discrepancies_found?: string;
			issues?: ReturnType<typeof Issue.prototype.toObject>[];
		}): AuditReport {
			const message = new AuditReport({});
			if (data.discrepancies_found != null) {
				message.discrepancies_found = data.discrepancies_found;
			}
			if (data.issues != null) {
				message.issues = data.issues.map((item) =>
					Issue.fromObject(item),
				);
			}
			return message;
		}
		toObject() {
			const data: {
				discrepancies_found?: string;
				issues?: ReturnType<typeof Issue.prototype.toObject>[];
			} = {};
			if (this.discrepancies_found != null) {
				data.discrepancies_found = this.discrepancies_found;
			}
			if (this.issues != null) {
				data.issues = this.issues.map((item: Issue) => item.toObject());
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.discrepancies_found.length)
				writer.writeString(1, this.discrepancies_found);
			if (this.issues.length)
				writer.writeRepeatedMessage(2, this.issues, (item: Issue) =>
					item.serialize(writer),
				);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuditReport {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new AuditReport();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.discrepancies_found = reader.readString();
						break;
					case 2:
						reader.readMessage(message.issues, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								2,
								Issue.deserialize(reader),
								Issue,
							),
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): AuditReport {
			return AuditReport.deserialize(bytes);
		}
	}
	export class Issue extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(data?: any[] | {}) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
			}
		}
		static fromObject(data: {}): Issue {
			const message = new Issue({});
			return message;
		}
		toObject() {
			const data: {} = {};
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Issue {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new Issue();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Issue {
			return Issue.deserialize(bytes);
		}
	}
	export class Null extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(data?: any[] | {}) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[],
				this.#one_of_decls,
			);
			if (!Array.isArray(data) && typeof data == "object") {
			}
		}
		static fromObject(data: {}): Null {
			const message = new Null({});
			return message;
		}
		toObject() {
			const data: {} = {};
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Null {
			const reader =
					bytes instanceof pb_1.BinaryReader
						? bytes
						: new pb_1.BinaryReader(bytes),
				message = new Null();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Null {
			return Null.deserialize(bytes);
		}
	}
	interface GrpcUnaryServiceInterface<P, R> {
		(
			message: P,
			metadata: grpc_1.Metadata,
			options: grpc_1.CallOptions,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientUnaryCall;
		(
			message: P,
			metadata: grpc_1.Metadata,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientUnaryCall;
		(
			message: P,
			options: grpc_1.CallOptions,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientUnaryCall;
		(
			message: P,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientUnaryCall;
	}
	interface GrpcStreamServiceInterface<P, R> {
		(
			message: P,
			metadata: grpc_1.Metadata,
			options?: grpc_1.CallOptions,
		): grpc_1.ClientReadableStream<R>;
		(
			message: P,
			options?: grpc_1.CallOptions,
		): grpc_1.ClientReadableStream<R>;
	}
	interface GrpWritableServiceInterface<P, R> {
		(
			metadata: grpc_1.Metadata,
			options: grpc_1.CallOptions,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientWritableStream<P>;
		(
			metadata: grpc_1.Metadata,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientWritableStream<P>;
		(
			options: grpc_1.CallOptions,
			callback: grpc_1.requestCallback<R>,
		): grpc_1.ClientWritableStream<P>;
		(callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
	}
	interface GrpcChunkServiceInterface<P, R> {
		(
			metadata: grpc_1.Metadata,
			options?: grpc_1.CallOptions,
		): grpc_1.ClientDuplexStream<P, R>;
		(options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
	}
	interface GrpcPromiseServiceInterface<P, R> {
		(
			message: P,
			metadata: grpc_1.Metadata,
			options?: grpc_1.CallOptions,
		): Promise<R>;
		(message: P, options?: grpc_1.CallOptions): Promise<R>;
	}
	export abstract class UnimplementedIndexLedgerService {
		static definition = {
			RecordTransaction: {
				path: "/core.IndexLedger/RecordTransaction",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: Transaction) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					Transaction.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: Status) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					Status.deserialize(new Uint8Array(bytes)),
			},
			UpdateTransaction: {
				path: "/core.IndexLedger/UpdateTransaction",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: TransactionUpdate) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					TransactionUpdate.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: Status) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					Status.deserialize(new Uint8Array(bytes)),
			},
			GetTransactionDetails: {
				path: "/core.IndexLedger/GetTransactionDetails",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: TransactionId) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					TransactionId.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: Transaction) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					Transaction.deserialize(new Uint8Array(bytes)),
			},
			ListTransactions: {
				path: "/core.IndexLedger/ListTransactions",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: TransactionLimit) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					TransactionLimit.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: TransactionList) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					TransactionList.deserialize(new Uint8Array(bytes)),
			},
			AuditLedger: {
				path: "/core.IndexLedger/AuditLedger",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: Null) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					Null.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: AuditReport) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					AuditReport.deserialize(new Uint8Array(bytes)),
			},
			SearchTransactionsByUser: {
				path: "/core.IndexLedger/SearchTransactionsByUser",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: UserId) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					UserId.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: TransactionList) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					TransactionList.deserialize(new Uint8Array(bytes)),
			},
			GetAccountBalance: {
				path: "/core.IndexLedger/GetAccountBalance",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: UserId) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					UserId.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: CurrencyValue) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					CurrencyValue.deserialize(new Uint8Array(bytes)),
			},
			CalculateTotalLedgerValue: {
				path: "/core.IndexLedger/CalculateTotalLedgerValue",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: Null) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					Null.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: CurrencyValue) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					CurrencyValue.deserialize(new Uint8Array(bytes)),
			},
			VerifyTransactionIntegrity: {
				path: "/core.IndexLedger/VerifyTransactionIntegrity",
				requestStream: false,
				responseStream: false,
				requestSerialize: (message: TransactionId) =>
					Buffer.from(message.serialize()),
				requestDeserialize: (bytes: Buffer) =>
					TransactionId.deserialize(new Uint8Array(bytes)),
				responseSerialize: (message: Status) =>
					Buffer.from(message.serialize()),
				responseDeserialize: (bytes: Buffer) =>
					Status.deserialize(new Uint8Array(bytes)),
			},
		};
		[method: string]: grpc_1.UntypedHandleCall;
		abstract RecordTransaction(
			call: grpc_1.ServerUnaryCall<Transaction, Status>,
			callback: grpc_1.sendUnaryData<Status>,
		): void;
		abstract UpdateTransaction(
			call: grpc_1.ServerUnaryCall<TransactionUpdate, Status>,
			callback: grpc_1.sendUnaryData<Status>,
		): void;
		abstract GetTransactionDetails(
			call: grpc_1.ServerUnaryCall<TransactionId, Transaction>,
			callback: grpc_1.sendUnaryData<Transaction>,
		): void;
		abstract ListTransactions(
			call: grpc_1.ServerUnaryCall<TransactionLimit, TransactionList>,
			callback: grpc_1.sendUnaryData<TransactionList>,
		): void;
		abstract AuditLedger(
			call: grpc_1.ServerUnaryCall<Null, AuditReport>,
			callback: grpc_1.sendUnaryData<AuditReport>,
		): void;
		abstract SearchTransactionsByUser(
			call: grpc_1.ServerUnaryCall<UserId, TransactionList>,
			callback: grpc_1.sendUnaryData<TransactionList>,
		): void;
		abstract GetAccountBalance(
			call: grpc_1.ServerUnaryCall<UserId, CurrencyValue>,
			callback: grpc_1.sendUnaryData<CurrencyValue>,
		): void;
		abstract CalculateTotalLedgerValue(
			call: grpc_1.ServerUnaryCall<Null, CurrencyValue>,
			callback: grpc_1.sendUnaryData<CurrencyValue>,
		): void;
		abstract VerifyTransactionIntegrity(
			call: grpc_1.ServerUnaryCall<TransactionId, Status>,
			callback: grpc_1.sendUnaryData<Status>,
		): void;
	}
	export class IndexLedgerClient extends grpc_1.makeGenericClientConstructor(
		UnimplementedIndexLedgerService.definition,
		"IndexLedger",
		{},
	) {
		constructor(
			address: string,
			credentials: grpc_1.ChannelCredentials,
			options?: Partial<grpc_1.ChannelOptions>,
		) {
			super(address, credentials, options);
		}
		RecordTransaction: GrpcUnaryServiceInterface<Transaction, Status> = (
			message: Transaction,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<Status>,
			options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>,
			callback?: grpc_1.requestCallback<Status>,
		): grpc_1.ClientUnaryCall => {
			return super.RecordTransaction(
				message,
				metadata,
				options,
				callback,
			);
		};
		UpdateTransaction: GrpcUnaryServiceInterface<
			TransactionUpdate,
			Status
		> = (
			message: TransactionUpdate,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<Status>,
			options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>,
			callback?: grpc_1.requestCallback<Status>,
		): grpc_1.ClientUnaryCall => {
			return super.UpdateTransaction(
				message,
				metadata,
				options,
				callback,
			);
		};
		GetTransactionDetails: GrpcUnaryServiceInterface<
			TransactionId,
			Transaction
		> = (
			message: TransactionId,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<Transaction>,
			options?: grpc_1.CallOptions | grpc_1.requestCallback<Transaction>,
			callback?: grpc_1.requestCallback<Transaction>,
		): grpc_1.ClientUnaryCall => {
			return super.GetTransactionDetails(
				message,
				metadata,
				options,
				callback,
			);
		};
		ListTransactions: GrpcUnaryServiceInterface<
			TransactionLimit,
			TransactionList
		> = (
			message: TransactionLimit,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<TransactionList>,
			options?:
				| grpc_1.CallOptions
				| grpc_1.requestCallback<TransactionList>,
			callback?: grpc_1.requestCallback<TransactionList>,
		): grpc_1.ClientUnaryCall => {
			return super.ListTransactions(message, metadata, options, callback);
		};
		AuditLedger: GrpcUnaryServiceInterface<Null, AuditReport> = (
			message: Null,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<AuditReport>,
			options?: grpc_1.CallOptions | grpc_1.requestCallback<AuditReport>,
			callback?: grpc_1.requestCallback<AuditReport>,
		): grpc_1.ClientUnaryCall => {
			return super.AuditLedger(message, metadata, options, callback);
		};
		SearchTransactionsByUser: GrpcUnaryServiceInterface<
			UserId,
			TransactionList
		> = (
			message: UserId,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<TransactionList>,
			options?:
				| grpc_1.CallOptions
				| grpc_1.requestCallback<TransactionList>,
			callback?: grpc_1.requestCallback<TransactionList>,
		): grpc_1.ClientUnaryCall => {
			return super.SearchTransactionsByUser(
				message,
				metadata,
				options,
				callback,
			);
		};
		GetAccountBalance: GrpcUnaryServiceInterface<UserId, CurrencyValue> = (
			message: UserId,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<CurrencyValue>,
			options?:
				| grpc_1.CallOptions
				| grpc_1.requestCallback<CurrencyValue>,
			callback?: grpc_1.requestCallback<CurrencyValue>,
		): grpc_1.ClientUnaryCall => {
			return super.GetAccountBalance(
				message,
				metadata,
				options,
				callback,
			);
		};
		CalculateTotalLedgerValue: GrpcUnaryServiceInterface<
			Null,
			CurrencyValue
		> = (
			message: Null,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<CurrencyValue>,
			options?:
				| grpc_1.CallOptions
				| grpc_1.requestCallback<CurrencyValue>,
			callback?: grpc_1.requestCallback<CurrencyValue>,
		): grpc_1.ClientUnaryCall => {
			return super.CalculateTotalLedgerValue(
				message,
				metadata,
				options,
				callback,
			);
		};
		VerifyTransactionIntegrity: GrpcUnaryServiceInterface<
			TransactionId,
			Status
		> = (
			message: TransactionId,
			metadata:
				| grpc_1.Metadata
				| grpc_1.CallOptions
				| grpc_1.requestCallback<Status>,
			options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>,
			callback?: grpc_1.requestCallback<Status>,
		): grpc_1.ClientUnaryCall => {
			return super.VerifyTransactionIntegrity(
				message,
				metadata,
				options,
				callback,
			);
		};
	}
}
